[

{
    "id":"1",
    "topic": "DSA",
    "sub_topic":"Arrays",
    "description":"An <strong>array</strong><p class='text-3xl'> is a data structure</p> that contains a group of elements of the same data type and stores them together in contiguous memory locations. Computer programmers use arrays in their programs to organize sets of data in a way that can be easily sorted and searched. They are more efficient at storing data than separate variables and can help a program run faster. Arrays are a very versatile method of storing data in a program. For example, a search engine may use an array to save a list of search results. It can display one element from that array at a time, in sequence, until it reaches either a specified number of results or the final value stored in the array. Since these values are all stored in one large block of memory instead of in separate variables stored in multiple locations, the results are shown quickly and efficiently. An array containing six values and their corresponding index addresses An array containing six values and their corresponding index addresses Since an array stores its values in contiguous memory locations,<ul class='list-disc'> <li>the size of an array is set when created.</li><li>the size of an array is set when created.</li><li>the size of an array is set when created.</li></ul> <br><br> The data type, like integer or string, is also defined at creation. A program can reference individual values in an array using the array name combined with that value's index address. In most languages, the index starts with 0 and increments from there. However, some languages start the index at 1, while others allow the programmer to choose whether an index starts with 0 or 1. Creating and Using an Array The syntax in C++ for creating an array and storing values in it looks like this: int characterStats[6] = {15, 14, 13, 12, 10, 8}; The int statement sets the data type as integer, and characterStats gives the array a name. The square brackets [] specify that it is an array, while the number inside the brackets determines its length. The values in the curly brackets {}, separated by commas, are the values contained in the array. The syntax for displaying a specific value in an array may look like this: print(characterStats[2]); Since this array's index starts with 0, this statement would output the number 13, the array's third value. Programmers may also use while and for loops with arrays to output multiple values from an array in sequence with a single command.<br><br>An <br><br><strong>array</strong><br> is a data structure that contains a group of elements of the same data type and stores them together in contiguous memory locations. Computer programmers use arrays in their programs to organize sets of data in a way that can be easily sorted and searched. They are more efficient at storing data than separate variables and can help a program run faster. Arrays are a very versatile method of storing data in a program. For example, a search engine may use an array to save a list of search results. It can display one element from that array at a time, in sequence, until it reaches either a specified number of results or the final value stored in the array. Since these values are all stored in one large block of memory instead of in separate variables stored in multiple locations, the results are shown quickly and efficiently. An array containing six values and their corresponding index addresses An array containing six values and their corresponding index addresses Since an array stores its values in contiguous memory locations, the size of an array is set when created. <br><br> The data type, like integer or string, is also defined at creation. A program can reference individual values in an array using the array name combined with that value's index address. In most languages, the index starts with 0 and increments from there. However, some languages start the index at 1, while others allow the programmer to choose whether an index starts with 0 or 1. Creating and Using an Array The syntax in C++ for creating an array and storing values in it looks like this: int characterStats[6] = {15, 14, 13, 12, 10, 8}; The int statement sets the data type as integer, and characterStats gives the array a name. The square brackets [] specify that it is an array, while the number inside the brackets determines its length. The values in the curly brackets {}, separated by commas, are the values contained in the array. The syntax for displaying a specific value in an array may look like this: print(characterStats[2]); Since this array's index starts with 0, this statement would output the number 13, the array's third value. Programmers may also use while and for loops with arrays to output multiple values from an array in sequence with a single command.",

    "example":"Let's suppose a class consists of ten students, and the class has to publish their results. If you had declared all ten variables individually, it would be challenging to manipulate and maintain the data. If more students were to join, it would become more difficult to declare all the variables and keep track of it. To overcome this problem, arrays came into the picture.",

    "image":["/logo.jpg", "/logo192.png"]
},

{
    "id":"2",
    "topic": "DSA",
    "sub_topic":"LinkedList",
    "description":"Linked list is a linear data structure that includes a series of connected nodes. Linked list can be defined as the nodes that are randomly stored in the memory. <br><br>A node in the linked list contains two parts, i.e., first is the data part and second is the address part. The last node of the list contains a pointer to the null.<br><br> After array, linked list is the second most used data structure. In a linked list, every link contains a connection to another link. Representation of a Linked list Linked list can be represented as the connection of nodes in which each node points to the next node of the list. Linked list Till now, we have been using array data structure to organize the group of elements that are to be stored individually in the memory. However, Array has several advantages and disadvantages that must be known to decide the data structure that will be used throughout the program. Now, the question arises why we should use linked list over array? Why use linked list over array? Linked list is a data structure that overcomes the limitations of arrays.<br><br> Let's first see some of the limitations of arrays - The size of the array must be known in advance before using it in the program. Increasing the size of the array is a time taking process. It is almost impossible to expand the size of the array at run time. All the elements in the array need to be contiguously stored in the memory. Inserting an element in the array needs shifting of all its predecessors. Linked list is useful because - It allocates the memory dynamically. All the nodes of the linked list are non-contiguously stored in the memory and linked together with the help of pointers. In linked list, size is no longer a problem since we do not need to define its size at the time of declaration.<br><br> List grows as per the program's demand and limited to the available memory space.",

    "example":"Each node holds a single value and a reference to the next node in the list. The list has a head, which is a reference to the first node in the list, and a tail, which is a reference to the last node in the list. The nodes are not stored in a contiguous block of memory, but instead, each node holds the address of the next node in the list. Accessing elements in a singly linked list requires traversing the list from the head to the desired node, as there is no direct access to a specific node in memory.",

    "image":["./images/Linkedlist1.png", "./images/Linkedlist2.png"]
},

{
    "id": "3",
    "topic": "DSA",
    "sub_topic": "Stacks",
    "description": "A stack is a fundamental data structure in computer science that operates on a last-in, first-out (LIFO) principle. It's a collection of elements with two main operations: push, which adds an element to the top of the stack, and pop, which removes the top element from the stack.\n\n*Operations:\n- **Push:* Adds an element to the top of the stack.\n- *Pop:* Removes the top element from the stack.\n- *Peek (or Top):* Retrieves the top element without removing it.\n- *isEmpty:* Checks if the stack is empty.\n- *Size:* Returns the number of elements in the stack.\n\n*Implementation:\nStacks can be implemented using various data structures, such as arrays or linked lists. The choice of implementation depends on the requirements of the application and the operations' efficiency.\n\nCommon Applications:\n- **Expression Evaluation:* Stacks are used in evaluating expressions, such as infix, postfix, and prefix notation.\n- *Function Call Management:* Stacks are used to manage function calls and recursion in programming languages.\n- *Backtracking:* Stacks are employed in algorithms involving backtracking, like depth-first search.\n- *Undo Functionality:* Stacks can be used to implement undo functionality in applications.\n- *Parsing:* Stacks are used in parsing algorithms, such as parsing XML or HTML documents.\n- *Memory Management:* Stacks are used in managing memory allocation and deallocation, such as in the call stack of a program.\n\n*Complexity:\n- **Push:* O(1) - constant time complexity.\n- *Pop:* O(1) - constant time complexity.\n- *Peek:* O(1) - constant time complexity.\n- *isEmpty:* O(1) - constant time complexity.\n- *Size:* O(1) - constant time complexity.",

    "example":"Now, assume that you have a stack of books. You can only see the top, i.e., the top-most book, namely 40, which is kept top of the stack. If you want to insert a new book first, namely 50, you must update the top and then insert a new text. And if you want to access any other book other than the topmost book that is 40, you first remove the topmost book from the stack, and then the top will point to the next topmost book. working-of-stack. After working on the representation of stacks in data structures, you will see some basic operations performed on the stacks in data structures.",

    "image":["./images/Stack1.png", "./images/Stack2.png"]
},

{
    "id":"4",
    "topic": "DSA",
    "sub_topic":"Queue",
    "description":"A queue is a linear data structure where elements are stored in the FIFO (First In First Out) principle where the first element inserted would be the first element to be accessed. A queue is an Abstract Data Type (ADT) similar to stack, the thing that makes queue different from stack is that a queue is open at both its ends. The data is inserted into the queue through one end and deleted from it using the other end. Queue is very frequently used in most programming languages. car A real-world example of queue can be a single-lane one-way road, where the vehicle enters first, exits first. More real-world examples can be seen as queues at the ticket windows and bus-stops. Representation of Queues Similar to the stack ADT, a queue ADT can also be implemented using arrays, linked lists, or pointers. As a small example in this tutorial, we implement queues using a one-dimensional array. Representation of queues Basic Operations in Queue Queue operations also include initialization of a queue, usage and permanently deleting the data from the memory. The most fundamental operations in the queue ADT include: enqueue(), dequeue(), peek(), isFull(), isEmpty(). These are all built-in operations to carry out data manipulation and to check the status of the queue. Queue uses two pointers − front and rear. The front pointer accesses the data from the front end (helping in enqueueing) while the rear pointer accesses data from the rear end (helping in dequeuing).",

    "example":"Two pointers are there denoting two ends, FRONT and REAR. FRONT tracks the first element of the queue. REAR tracks the last element of the queue. Initially, set the value of FRONT and REAR to -1. Afterward, follow the above-given algorithms for the basic operations.",

    "image":["./images/Queue1.png","./images/Queue2.png"]
},

{
    "id":"5",
    "topic": "DSA",
    "sub_topic":"trees",
    "description":"Trees are hierarchical data structures widely used in computer science for organizing and storing data. Similar to real-world trees, they consist of nodes connected by edges, with a single node designated as the root. Each node may have zero or more children, and nodes with no children are called leaves.<br> Types of Trees: <br> 1.)Binary Trees: Each node in a binary tree has at most two children, typically referred to as the left child and the right child. <br> 2.)Binary Search Trees (BST): In a binary search tree, nodes are ordered in a specific way where the left child is less than the parent, and the right child is greater than the parent, facilitating efficient searching. <br> 3.)AVL Trees: AVL trees are self-balancing binary search trees, ensuring that the height difference between the left and right subtrees of any node is no more than one. <br> 4.)Red-Black Trees: Red-black trees are another type of self-balancing binary search tree with additional properties that ensure balance. <br> 5.)B-trees: B-trees are balanced tree data structures commonly used in databases and file systems for efficient data storage and retrieval. <br> <br>  Tree Traversal Algorithms: • Pre-order Traversal: Visit the root node first, followed by its left subtree and then its right subtree. <br> • In-order Traversal: Visit the left subtree first, followed by the root node, and then the right subtree. <br> • Post-order Traversal: Visit the left and right subtrees first, followed by the root node. <br> • Level-order Traversal: Visit nodes level by level, starting from the root and moving to the next level. <br> <br> Operations on Trees: <br> • Insertion: Adding a new node to the tree while maintaining its structural properties. <br> • Deletion: Removing a node from the tree and adjusting the structure accordingly. <br> • Searching: Finding a specific node or value within the tree efficiently. <br> <br> Application of Trees: <br> Trees have various applications, including representing hierarchical data like file systems and HTML DOM, organizing and searching large datasets efficiently, and implementing algorithms like Huffman coding for data compression. <br> <br> Real World Examples: <br> • File Systems: File systems often use tree structures to organize directories and files, with directories acting as internal nodes and files as leaf nodes. <br> • HTML DOM: The Document Object Model (DOM) in HTML represents the structure of web pages using a tree, facilitating manipulation and interaction with page elements. <br> • Family Trees: Family relationships can be represented using tree data structures, with individuals as nodes and parent-child relationships as edges.",

    "example":"include trees example",

    "image":["./images/Array1.png", "./images/Array2.png"]
},

{
    "id":"6",
    "topic": "DSA",
    "sub_topic":"Graphs",
    "description":"Graphs are a fundamental data structure in computer science that model relationships between objects. They consist of a set of vertices (nodes) connected by edges (links). Graphs find wide applications in various fields such as computer networking, social network analysis, transportation systems, and more. Understanding graphs and their properties is crucial for mastering data structures and algorithms.<br><br><br> <strong> Introduction to Graphs:</strong>  <br> <strong> 1) Vertex (Node): </strong> A vertex, or node, is a fundamental unit of a graph. It represents an entity or object and can contain additional information, such as a unique identifier, data payload, or attributes. Each vertex in a graph must have a unique identifier within the context of the graph. <br> 2) Edge (Link): <br> • An edge, or link, connects two vertices in a graph. It represents a relationship or connection between the entities represented by the vertices. <br> • An edge can be directed or undirected:<br> &nbsp; &nbsp; a) In a directed graph, edges have a specific direction indicating a one-way relationship from one vertex to another. <br> &nbsp; &nbsp; b) In an undirected graph, edges do not have a direction, indicating a symmetric relationship between vertices. <br> 3) Weight: <br> • Edges in a graph can have associated weights or costs. <br> • A weight represents a value assigned to an edge, typically indicating the cost or distance associated with traversing that edge. <br> •  Weights are commonly used in algorithms like Dijkstra's algorithm for finding shortest paths in weighted graphs. <br> 4) Adjacency: <br> • The adjacency of a vertex refers to its neighboring vertices. <br> • In an adjacency list representation, each vertex maintains a list of adjacent vertices it's connected to.<br> • In an adjacency matrix representation, a matrix is used to represent the connections between vertices, where a value of 1 indicates an edge and 0 indicates no edge. <br> 5) Directed Acyclic Graph (DAG): <br> • A directed acyclic graph is a specialized type of graph where edges have a direction, and there are no cycles (loops) present. <br> • DAGs are often used to represent dependencies between tasks, such as in scheduling or project management. <br><br> <strong> Types of Graphs: </strong> <br> 1) Directed Graphs (Digraphs): In directed graphs, edges have a direction, indicating a one-way relationship between nodes. <br> 2) Undirected Graphs: In undirected graphs, edges have no direction, representing a bidirectional relationship between nodes. <br> 3) Weighted Graphs: Weighted graphs assign a weight or cost to each edge, representing the strength or distance of the connection between nodes. <br> 4)Sparse Graphs: Sparse graphs have relatively few edges compared to the total number of possible edges. <br> 5) Dense Graphs: Dense graphs have a high density of edges, with most or all possible edges present.  <br><br><strong>Graph Representations:</strong><br> • Adjacency Matrix: A two-dimensional array where the presence or absence of an edge between two nodes is represented by a binary value or weight. <br> • Adjacency List: A collection of lists or arrays where each list contains the nodes adjacent to a particular node. <br> • Edge List: A list of tuples or pairs representing the edges in the graph, optionally including weights.  <br><br><strong>Graph Traversal Algorithms: </strong><br> • Depth-First Search (DFS): Traverse as far as possible along each branch before backtracking, often used for graph traversal and cycle detection. <br> • Breadth-First Search (BFS): Explore all neighbor nodes at the present depth before moving on to nodes at the next depth, commonly used for shortest path algorithms and network analysis.  <br><br><strong>Graph Algorithms:</strong><br> • Shortest Path Algorithms: Find the shortest path between two nodes in a graph, such as Dijkstra's algorithm and Bellman-Ford algorithm. <br> • Minimum Spanning Tree (MST) Algorithms: Find the minimum spanning tree of a graph, including algorithms like Prim's algorithm and Kruskal's algorithm. <br> • Topological Sorting: Arrange the nodes of a directed graph in a linear order that respects the direction of the edges. <br> • Graph Coloring: Assign colors to the nodes of a graph such that no two adjacent nodes share the same color.  <br><br><strong>Applications of Graphs:</strong><br> • Social Networks: Representing relationships between individuals in social networks like Facebook and LinkedIn. <br> • Transportation Networks: Modeling road networks, flight routes, and public transportation systems. <br> • Computer Networks: Analyzing network connectivity, routing algorithms, and network security. <br> • Recommendation Systems: Generating personalized recommendations based on user preferences and behavior.  <br><br><strong>Real-World Examples:</strong> <br> • Google Maps: Uses graph algorithms to find the shortest route between locations and to display alternative routes based on traffic conditions. <br> • Facebook: Represents users as nodes and friendships as edges in a graph to recommend friends and suggest mutual connections. <br> • Web Crawlers: Use graph traversal algorithms to discover and index web pages by following hyperlinks. ",

    "example":"Consider a social network where users are represented as vertices and friendships between users are represented as edges in the graph. Let's say we have four users: Alice, Bob, Charlie, and David. <br>We can represent this social network as a graph where each user is a vertex and friendships are edges between vertices. <br> Here's how the graph would look: <br> Vertices: Alice, Bob, Charlie, David <br> Edges: Friendship between Alice and Bob, Alice and Charlie, Bob and David, Charlie and David <br> Graph representation: <br> In this graph: <br> Alice is friends with Bob and Charlie. <br> Bob is friends with Alice and David. <br> Charlie is friends with Alice and David. <br>  David is friends with Bob and Charlie. ",

    "image":["./images/Graph1.png", "./images/Array2.png"]
},

{
    "id":"7",
    "topic": "OOP",
    "sub_topic":"Abstraction",
    "description":"Abstraction is a fundamental concept in object-oriented programming that involves simplifying complex systems by focusing on the essential characteristics while hiding unnecessary details. It allows programmers to model real-world entities as objects with specific behaviors and properties, facilitating software design, implementation, and maintenance. <br> <br> Key Concepts: <br> 1) Classes and Objects: Abstraction in OOP is achieved through the creation of classes, which serve as blueprints for objects. Objects are instances of classes and encapsulate data (attributes) and behaviors (methods) relevant to a particular entity. <br> 2) Encapsulation: Encapsulation is the bundling of data and methods that operate on that data within a single unit (class), preventing direct access to internal details from outside the class.<br> 3) Data Hiding: Data hiding is a principle of encapsulation that restricts access to certain attributes or methods, allowing only authorized interactions with an object's internal state. <br> 4) Interface and Implementation: Abstraction separates the interface (public methods) from the implementation (private methods and attributes), enabling objects to interact with each other through well-defined interfaces while hiding implementation details. <br> 5) Polymorphism: Polymorphism allows objects of different classes to be treated as objects of a common superclass, enabling code reuse and flexibility in OOP designs. <br> 6) Inheritance: Inheritance is a mechanism that allows a class (subclass) to inherit properties and behaviors from another class (superclass), promoting code reuse and facilitating hierarchical relationships between classes. <br> <br> Benefits of Abstraction: <br> 1) Modularity: Abstraction promotes modular design by breaking down complex systems into smaller, more manageable components (classes and objects). <br> 2) Encapsulation of Complexity: Abstraction hides unnecessary details and exposes only relevant information, simplifying the understanding and use of software components <br> 3) Code Reusability: Abstraction encourages the reuse of existing classes and objects, leading to more efficient development and maintenance of software systems. <br> 4) Ease of Maintenance: By isolating changes to specific classes or objects, abstraction reduces the impact of modifications on other parts of the codebase, making maintenance easier and less error-prone. <br> 5) Enhanced Scalability: Abstraction facilitates the addition of new features and functionalities to a software system without disrupting existing components, supporting scalability and evolution over time. <br> <br> Real-World Examples: <br> 1) Bank Account System: In a bank account system, the Account class may abstract common properties and behaviors of different types of accounts (e.g., savings account, checking account) while hiding implementation details. <br> 2) Vehicle Management System: A Vehicle class may abstract common attributes and methods shared by different types of vehicles (e.g., cars, trucks, motorcycles), allowing for polymorphic behavior and code reuse. <br> 3) Online Shopping Platform: The Product class in an online shopping platform abstracts product-related information and operations, enabling interactions with various types of products (e.g., electronics, clothing, books) through a unified interface.",

    "example":"Each node holds a single value and a reference to the next node in the list. The list has a head, which is a reference to the first node in the list, and a tail, which is a reference to the last node in the list. The nodes are not stored in a contiguous block of memory, but instead, each node holds the address of the next node in the list. Accessing elements in a singly linked list requires traversing the list from the head to the desired node, as there is no direct access to a specific node in memory.",

    "image":["./images/Linkedlist1.png", "./images/Linkedlist2.png"]
},

{
    "id":"8",
    "topic": "OOP",
    "sub_topic":"Encapsulation",
    "description":"Encapsulation is a fundamental principle of object-oriented programming that involves bundling data (attributes) and methods (functions or procedures) that operate on the data into a single unit (class). It allows for the hiding of internal state and implementation details of objects, while exposing a public interface for interacting with them. <br> <br> Key Concepts: <br> 1) Access Modifiers: In most object-oriented programming languages, access modifiers such as public, private, and protected are used to control the visibility of class members (attributes and methods). <br> 2) Public Members: Public members are accessible from outside the class and can be accessed and modified directly by external code. <br> 3) Private Members: Private members are accessible only within the class itself and cannot be accessed or modified directly from outside the class. They are typically accessed through public methods (getters and setters). <br> 4) Getters and Setters: Getters (accessor methods) are public methods used to retrieve the values of private attributes, while setters (mutator methods) are public methods used to modify the values of private attributes. They provide controlled access to the internal state of objects. <br> 5) Information Hiding: Encapsulation facilitates information hiding by restricting direct access to the internal state of objects, which helps prevent accidental modification and promotes data integrity. <br> 6) Abstraction: Encapsulation and abstraction are closely related concepts in OOP, with encapsulation providing the mechanism for hiding implementation details and exposing a simplified interface to users of the class. <br> <br> Benefits of Encapsulation: <br> 1) Modularity: Encapsulation promotes modular design by encapsulating related data and behavior within a single class, making it easier to manage and understand. <br> 2) Data Integrity: By restricting direct access to class members, encapsulation helps ensure data integrity and prevents unintended modification of object state. <br> 3) Code Flexibility: Encapsulation allows for changes to the internal implementation of a class without affecting external code that interacts with the class through its public interface. <br> 4) Security: Encapsulation enhances security by limiting access to sensitive data and operations, reducing the risk of unauthorized manipulation or misuse. <br> 5) Code Reusability: Encapsulation facilitates code reuse by encapsulating common functionality within reusable class modules, leading to more efficient and maintainable codebases. <br> <br> Real World Examples: <br> 1) Bank Account Class: In a bank account class, attributes such as account balance and account number may be encapsulated as private members, with public methods like deposit and withdraw providing controlled access to modify the account balance. <br> 2) Employee Class: In an employee class, attributes such as employee ID, name, and salary may be encapsulated as private members, with public methods like getSalary and setSalary providing controlled access to the salary attribute. <br> 3) Vehicle Class: In a vehicle class representing different types of vehicles, attributes such as make, model, and year may be encapsulated as private members, with public methods like getMake and getModel providing controlled access to retrieve vehicle information.",

    "example":"Now, assume that you have a stack of books. You can only see the top, i.e., the top-most book, namely 40, which is kept top of the stack. If you want to insert a new book first, namely 50, you must update the top and then insert a new text. And if you want to access any other book other than the topmost book that is 40, you first remove the topmost book from the stack, and then the top will point to the next topmost book. working-of-stack. After working on the representation of stacks in data structures, you will see some basic operations performed on the stacks in data structures.",

    "image":["./images/Stack1.png", "./images/Stack2.png"]
},

{
    "id":"9",
    "topic": "OOP",
    "sub_topic":"Polymorphism",
    "description":"Polymorphism is a key concept in object-oriented programming that allows objects of different classes to be treated as objects of a common superclass. It enables code to be written in a way that is more generic and flexible, facilitating code reuse and enhancing the maintainability and scalability of software systems. <br> <br> Key Concepts: <br> 1) Static Polymorphism: Static polymorphism, also known as compile-time polymorphism, is achieved through method overloading and operator overloading. Method overloading involves defining multiple methods in a class with the same name but different parameter lists, while operator overloading allows operators to be redefined for custom data types. <br> 2) Dynamic Polymorphism: Dynamic polymorphism, also known as runtime polymorphism, is achieved through method overriding and virtual functions. Method overriding involves redefining a method in a subclass with the same signature as a method in its superclass, allowing the subclass method to be invoked at runtime based on the actual type of the object. <br> 3) Late Binding: Dynamic polymorphism relies on late binding or dynamic dispatch, where the decision about which method to invoke is deferred until runtime based on the actual type of the object. <br> 4) Inheritance: Polymorphism is closely related to inheritance, as it enables objects of subclasses to be treated as objects of their superclass, promoting code reuse and facilitating hierarchical relationships between classes. <br> 5) Interface Polymorphism: Interface polymorphism, also known as polymorphic interfaces, allows objects of different classes that implement the same interface to be treated uniformly, enabling interchangeable usage of objects based on their common interface. <br> <br> Benefits of Polymorphism: <br> 1) Code Reusability: Polymorphism promotes code reuse by allowing subclasses to inherit and override methods from their superclass, reducing redundancy and improving maintainability. <br> 2) Flexibility: Polymorphism enhances the flexibility of software systems by enabling objects to be treated uniformly based on their common interface, regardless of their specific implementation. <br> 3) Extensibility: Polymorphism supports extensibility by allowing new subclasses to be added to the system without modifying existing code, facilitating the addition of new features and functionalities. <br> 4) Scalability: Polymorphism facilitates scalability by promoting modular design and hierarchical relationships between classes, making it easier to manage and extend software systems as they grow in size and complexity. <br> 5) Ease of Maintenance: Polymorphism simplifies maintenance by encapsulating variations in behavior within subclasses and providing a consistent interface for interacting with objects, reducing the impact of changes on other parts of the codebase. <br> <br> Real-World Examples: <br> 1) Shape Hierarchy: In a shape hierarchy, the superclass Shape may define a virtual method area(), which is overridden by subclasses such as Circle and Rectangle to calculate the area of specific shapes. <br> 2) Animal Hierarchy: In an animal hierarchy, the superclass Animal may define a virtual method makeSound(), which is overridden by subclasses such as Dog and Cat to produce specific animal sounds. <br> 3) Employee Hierarchy: In an employee hierarchy, the superclass Employee may define a virtual method calculateSalary(), which is overridden by subclasses such as Manager and Programmer to calculate salaries based on different criteria",

    "example":"Two pointers are there denoting two ends, FRONT and REAR. FRONT tracks the first element of the queue. REAR tracks the last element of the queue. Initially, set the value of FRONT and REAR to -1. Afterward, follow the above-given algorithms for the basic operations.",

    "image":["./images/Queue1.png","./images/Queue2.png"]
},

{
    "id":"10",
    "topic": "OOP",
    "sub_topic":"Inheritance",
    "description":"Inheritance is a fundamental concept in object-oriented programming that allows a class (subclass or derived class) to inherit properties and behaviors from another class (superclass or base class). It promotes code reuse, facilitates hierarchical relationships between classes, and enables polymorphic behavior in software systems. <br> <br> Key Concepts: <br> 1) Superclass and Subclass: Inheritance involves creating a hierarchy of classes, with the superclass serving as a template or blueprint for creating subclasses. Subclasses inherit attributes and methods from their superclass and can also define additional attributes and methods specific to their own functionality. <br> 2) Base and Derived Classes: The superclass is often referred to as the base class or parent class, while the subclass is referred to as the derived class or child class. <br> 3) Single Inheritance: Single inheritance refers to the ability of a class to inherit properties and behaviors from a single superclass. <br> 4) Multiple Inheritance: Multiple inheritance refers to the ability of a class to inherit properties and behaviors from multiple superclasses. While supported by some programming languages, multiple inheritance can lead to complexity and ambiguity and is often avoided in favor of other design patterns such as composition. <br> 5) Method Overriding: Subclasses can override (redefine) methods inherited from their superclass to provide specialized implementations. This allows subclasses to customize behavior while retaining the structure defined by the superclass. <br> 6) Access Modifiers: Inheritance can involve the inheritance of access modifiers such as public, private, and protected, which control the visibility of superclass members in subclasses. <br> <br> Benefits of Inheritance: <br> 1) Code Reuse: Inheritance promotes code reuse by allowing subclasses to inherit and reuse attributes and methods from their superclass, reducing redundancy and improving maintainability. <br> 2) Modularity: Inheritance facilitates modular design by organizing classes into hierarchical relationships, making it easier to manage and understand complex systems. <br> 3) Polymorphism: Inheritance enables polymorphic behavior, where objects of different subclasses can be treated as objects of their common superclass, promoting flexibility and extensibility. <br> 4) Consistency: Inheritance promotes consistency by defining common attributes and methods in a superclass, ensuring uniformity across subclasses. <br> 5) Ease of Maintenance: Inheritance simplifies maintenance by encapsulating common functionality within a superclass and allowing changes to be made in one place, with the modifications automatically reflected in all subclasses. <br> <br> Real-World Examples: <br> 1) Vehicle Hierarchy: In a vehicle hierarchy, a superclass Vehicle may define common attributes and methods such as speed and fuel consumption, with subclasses such as Car, Truck, and Motorcycle inheriting and customizing behavior specific to each type of vehicle. <br> 2) Employee Hierarchy: In an employee hierarchy, a superclass Employee may define common attributes and methods such as name and salary, with subclasses such as Manager and Programmer inheriting and extending functionality to represent different types of employees. <br> 3) Shape Hierarchy: In a shape hierarchy, a superclass Shape may define common attributes and methods such as area and perimeter, with subclasses such as Circle, Rectangle, and Triangle inheriting and implementing specialized behavior for different types of shapes.",

    "example":"Two pointers are there denoting two ends, FRONT and REAR. FRONT tracks the first element of the queue. REAR tracks the last element of the queue. Initially, set the value of FRONT and REAR to -1. Afterward, follow the above-given algorithms for the basic operations.",

    "image":["./images/Queue1.png","./images/Queue2.png"]
},

{
    "id":"11",
    "topic": "OOP",
    "sub_topic":"Inheritance",
    "description":"<p> hello <br> <p>hi</p> </p>",

    "example":"Two pointers are there denoting two ends, FRONT and REAR. FRONT tracks the first element of the queue. REAR tracks the last element of the queue. Initially, set the value of FRONT and REAR to -1. Afterward, follow the above-given algorithms for the basic operations.",

    "image":["./images/Queue1.png","./images/Queue2.png"]
},

{
    "id":"12",
    "topic": "SQL",
    "sub_topic":"Inheritance",
    "description":"<p> hello <br> <p>hi</p> </p>",

    "example":"Two pointers are there denoting two ends, FRONT and REAR. FRONT tracks the first element of the queue. REAR tracks the last element of the queue. Initially, set the value of FRONT and REAR to -1. Afterward, follow the above-given algorithms for the basic operations.",

    "image":["./images/Queue1.png","./images/Queue2.png"]
}


]